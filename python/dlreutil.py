# Warn but don't exit.
def warn(msg):   
    import sys    
    print >> sys.stderr, 'divfds: WARNING // '+msg
  
def argerror(arg,msg):    
    import sys    
    print >> sys.stderr, 'divfds: ERROR // '+arg+': '+msg
    sys.exit()

def error(msg):
    import sys    
    print >> sys.stderr, 'divfds: ERROR // '+msg
    sys.exit()

#Linear index from multiple subscripts.
#   SUB2IND is used to determine the equivalent single index
#   corresponding to a given set of subscript values.
#
#   IND = SUB2IND(SIZ,I,J) returns the linear index equivalent to the
#   row and column subscripts in the arrays I and J for a matrix of
#   size SIZ. 
#
#   I1,I2 must have the same size, and IND will have the same size
#   as I1,I2,...,IN. For an array A, if IND = SUB2IND(SIZE(A),I1,...,IN)),
#   then A(IND(k))=A(I1(k),...,IN(k)) for all k.
#    
#def sub2ind2(siz,xind,yind):
#
#    if (len(siz)!=2):
#        error('sub2ind:InvalidSize')
#
#    if (length(siz) != nargin-1):
#        #Adjust input
#        if (length(siz)<nargin-1):
#            #Adjust for trailing singleton dimensions
#            siz = (siz, np.ones(1,nargin-len(siz)-1))
#        else:
#            #Adjust for linear indexing on last element
#            siz = (siz[:nargin-2], np.prod(siz[nargin-1:]))
#    
#    #Compute linear indices
#    k = (1, np.cumprod(siz[:-1]))
#    ndx = 1
#    s = varargin{1}.shape #For size comparison
#    for i in len(siz):
#        v = varargin{i}
#        # Input checking
#        if (s != v.shape):
#            #Verify sizes of subscripts
#            error('sub2ind:SubscriptVectorSize')
#    
#        if (np.any(v < 1)) | (np.any(v > siz(i))):
#    
#            #Verify subscripts are within range
#            error('sub2ind:IndexOutOfRange')
#    
#        ndx = ndx + (v-1)*k(i)

#
# Read a pipes format descriptor file.
#
def readdes(fpath):
    
    # Read the header a line at a time    
    fh = open(fpath, 'r')
    header=''
    for line in fh:
    
        # Add it to the total header.
        header += line
       
        # If this line comprises only the string 'end' then it's the 
        # last line of the header.
        if (line.strip() == '\'end\''):
              fh.close()
              break          
    
    fh.close()
            
    # Remove all newlines and split the header by single quotes separated by a space, note that this 
    # assumes none of the descriptor fields are allowed to have single quotes.
    header = header.replace('\n','').split('\' \'')
    
    # Remove all single quotes from each item, then strip trailing and leading whitespace
    for i, thisheader in enumerate(header):
        header[i] = thisheader.replace('\'','').strip()
      
    # Now we have a non-messy list of all the separate phrases in the pipes header.
    
    # Test that the first field is the pipes header
    if header[0].find('Descripter file auto-generated by pipes') > -1:
        # Extract the short and long titles from the list.
        dess = header[1:-2:2]
        desl = header[2:-1:2]

        if dess.__len__() != desl.__len__():
            error(fpath+' does not appear to be a valid descriptor file.')
            return (-1,-1)  
        else:
           return (dess,desl)
    
    else:
        error(fpath+' does not appear to be a valid descriptor file.')
        return (-1,-1)


#
# Read a pipes format file with an embedded descriptor file as the header and return as a pandas array.
#
def readpipe(fpath):
    
    import numpy as np
    import pandas as pd
    
    # Read the header a line at a time    
    f = open(fpath, 'r')
    header=''
    for line in f:
    
        # Add it to the total header.
        header += line    
       
        # If this line contains the string 'end' then it's the 
        # last line of the descriptor
        if line.find('\'end\'') >= 0:
            # Number of bytes in the header, after this data starts
            pointer=header.__len__()
            break
    
    f.close()

    # Remove all newlines.
    header = header.replace('\n','')
    
    # Loop over whole descriptor
    words=-1
    thisword=''
    inword=False
    dess=[]
    desl=[]
    
    #print header
    
    for i in range(header.__len__()):

        c = header[i]

        if inword:
            if c=='\'':
                # End of a word
                inword=False
                if words > 0:
                    if thisword != 'end':
                        if words/2. == np.floor(words/2.):
                            # Even - desl
                            desl.append(thisword.strip())
                        else:
                            # Odd - dess
                            dess.append(thisword.strip())
                        thisword=''
                    else:
                        break
                else:
                    # If header line of descriptor then empty thisword
                    thisword=''
            else:    
                thisword += c
        else:
            # Not in a word
            if c=='\'':
                # Found a new word.
                inword=True
                words += 1            
            #else:
                # Not in a word and don't encounter a ' . Must be whitespace.
                # Do nothing.
                
    # Now reopen the file and read the binary
    numcol=dess.__len__()
    
    f = open(fpath,'rb')
    f.seek(pointer)
    
    #return (dess,desl) 
       
    # Read the binary data.
    narray = np.fromfile(f,dtype=float,count=-1,sep="")
        
    # If the file was empty or corrupt (i.e. there were incomplete records)
    numcol = dess.__len__()
    records = narray.size/numcol    
    if narray.size == 0:
        print 'Warning: '+fpath+' contains no binary data.'
        return 0
    elif records != np.floor(records):
        print 'Error: '+fpath+' has incomplete or corrupt binary data.'
        return -1
    else:
        # Reshape this 1D array into a 2D DataFrame
        dat = pd.DataFrame(narray.reshape((narray.size/numcol,numcol)))
        dat.columns = dess
    return dat